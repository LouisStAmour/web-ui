// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io';

// TODO(jmesserly): should be importing a compiler mirrors package.
// This is currently generated by the shell script.
import 'compile_mirrors.dart';

// TODO(jmesserly): pub is not creating a "packages" for us.
import '../lib/src/html5_utils.dart' show htmlElementNames;

const MY_NAME = 'build/gen_html_setters.sh';
const OUTPUT_NAME = 'lib/src/html5_setters.g.dart';

/**
 * Given a field name in `dart:html` gets the HTML attribute name.
 */
const fieldToAttribute = const {
  'acceptCharset': 'accept-charset',
  'defaultValue': 'default',
  // Yuck. http://dartbug.com/4550
  'webkitdropzone': 'dropzone',
  'htmlFor': 'for',
  'httpEquiv': 'http-equiv',
};


main() {
  print('''
This script uses compile time mirrors to get information from dart:html.
The information is used to create "$OUTPUT_NAME".
''');

  var sdk = Platform.environment['DART_SDK'];
  if (sdk == null) {
    print('DART_SDK path must be set. Use gen_html_setters.sh.');
    exit(1);
  }

  var htmlPath = new Path('dart:html');
  var svgPath = new Path('dart:svg');
  var libPath = new Path(sdk).append('/');
  var pkgPath = new Path(sdk).append('pkg/');

  var mirrors = new Compilation.library(
      [htmlPath, svgPath], libPath, pkgPath).mirrors;
  var html = mirrors.libraries['dart.dom.html'];

  var extendsCode = new StringBuffer();
  extendsCode.add('var htmlElementExtends = const {\n');

  var code = new StringBuffer();
  code.add('// This file is autogenerated by $MY_NAME. Do not edit.\n');
  code.add('library html5_setters;\n');

  var elemSet = new Set();
  for (var name in htmlElementNames.values) {
    _addElement(html.classes[name], elemSet);
  }
  _addElement(html.classes['UnknownElement'], elemSet);

  code.add('var htmlElementFields = const {\n');
  var elements = new List.from(elemSet);
  elements.sort((a, b) => a.displayName.compareTo(b.displayName));
  for (var cls in elements) {
    var element = cls.displayName;
    var setters = [];

    if (cls.superclass != null
        && cls.superclass.displayName.endsWith('Element')) {
      extendsCode.add("  '$element': '${cls.superclass.displayName}',\n");
    }

    // TODO(jmesserly): using "cls.setters" does not seem to work
    for (var member in cls.members.values) {
      if (member.simpleName.startsWith(r'$')) continue;
      if (member is! VariableMirror) continue;
      if (member.isFinal || member.isConst) continue;
      setters.add(member.displayName);
    }

    if (setters.length == 0) continue;

    code.add("  '$element': const {\n");
    for (var setter in setters) {
      var attr = fieldToAttribute[setter];
      if (attr == null) attr = setter.toLowerCase();
      code.add("    '$attr': '$setter',\n");
    }
    code.add('  },\n');
  }
  code.add('};\n\n');
  extendsCode.add('};\n');
  code.add(extendsCode.toString());

  var outPath = new Path(new Options().script).directoryPath
      .append('..').append(OUTPUT_NAME);

  new File.fromPath(outPath)
      .openSync(FileMode.WRITE)
      ..writeStringSync(code.toString())
      ..closeSync();

  print('Wrote $outPath.');
}

/** Add an element class and its element super classes to [elemSet]. */
void _addElement(ClassMirror cls, Set elemSet) {
  while (cls != null) {
    if (!cls.isOriginalDeclaration) cls = cls.originalDeclaration;
    if (!cls.displayName.endsWith('Element') || elemSet.contains(cls)) {
      break;
    }
    elemSet.add(cls);
    cls = cls.superclass;
  }
}
